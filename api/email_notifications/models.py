from django.db import models
from django.conf import settings
from api.base_models import MerlinBaseModel

class EmailTemplate(MerlinBaseModel):
    name = models.CharField(
        max_length=100,
        unique=True,
        help_text="Unique identifier for the email template"
    )
    subject = models.CharField(
        max_length=255,
        help_text="Subject of the email"
    )
    body = models.TextField(
        help_text="Body of the email with placeholders (e.g., {{name}}, {{role}})"
    )
    metadata = models.JSONField(
        null=True,
        blank=True,
        help_text="Optional metadata (e.g., version, language)"
    )

    class Meta:
        verbose_name = "قالبِ ایمیل"
        verbose_name_plural = "قالب‌های ایمیل"

    def __str__(self):
        return self.name
    
class EmailTrigger(MerlinBaseModel):
    EVENT_CHOICES = [
        ('new_form_assigned', 'New Form Assigned'),
        ('unchecked_form_reminder', 'Unchecked Form Reminder'),
    ]
    event_type = models.CharField(
        max_length=100,
        choices=EVENT_CHOICES,
        help_text='Event that triggers the email'
    )
    conditions = models.JSONField(
        # This is for selcetive triggering, or setting conditions in admin panel instead of hard-coding
        null=True,
        blank=True,
        help_text="Optional conditions for triggering the email (e.g., {\"role\": \"manager\"})"
    )
    template = models.ForeignKey(
        EmailTemplate,
        on_delete=models.CASCADE,
        related_name='triggers',
        help_text="The email template to use when the trigger fires"
    )
    placeholders = models.JSONField(
        default=dict, blank=True)  # E.g. {"user_name": "name", "user_role": "role"}

    class Meta:
        verbose_name = "تریگرِ ایمیل"
        verbose_name_plural = "ایمیل تریگرها"

    def __str__(self):
        return f"{self.event_type} - {self.template.name}"

class EmailLog(MerlinBaseModel):
    """  
    Model for logging email sending attempts and their outcomes.

    These logs are automatically generated by the email sending utility functions. They provide
    a mechanism for administrators to audit the email sending process, identify issues, and troubleshoot
    failures via the Django admin interface."""

    event_type = models.CharField(
        max_length=100,
        help_text="Event that triggered the email"
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.PROTECT,
        help_text="User to whom the email was sent"
    )
    email_template = models.ForeignKey(
        EmailTemplate,
        on_delete=models.SET_NULL,
        null=True,
        help_text="Email template used for sending the email"
    )
    subject = models.CharField(
        max_length=255,
        help_text="Rendered subject of the email"
    )
    body = models.TextField(
        help_text="Rendered body of the email"
    )
    status = models.CharField(
        max_length=20,
        default="Pending",
        help_text="Status of the email (e.g., Sent, Failed)"
    )
    error_message = models.TextField(
        blank=True,
        null=True,
        help_text="Error message if sending failed"
    )
    sent_at = models.DateTimeField(
        blank=True,
        null=True,
        help_text="Timestamp when the email was sent"
    )

    class Meta:
        verbose_name = "لاگ ایمیل‌های ارسالی"
        verbose_name_plural = "لاگ ایمیل‌های ارسالی"
    
    def __str__(self):
        return f"{self.event_type} to {self.user.email} - {self.status}"
